//
//  IssueListPresenter.swift
//  MyGitLab
//
//  Created by PHAM ANH TUAN on 11/06/2021.
//  Copyright (c) 2021 ___ORGANIZATIONNAME___. All rights reserved.
//
//  This file was generated by the üêç VIPER generator
//

import Foundation
import RxSwift
import RxCocoa
import Action

enum IssueListNavigationOption {
    case issueDetail(issue: MGLIssue)
}

protocol IssueListWireframeInterface: WireframeInterface {
    func navigate(to option: IssueListNavigationOption)
}

protocol IssueListViewInterface: ViewInterface, DSStatePresentable {
    var viewModels: BehaviorRelay<[DSIssueViewModel]> { get }
    var tableViewContentOffsetY: BehaviorRelay<CGFloat?> { get }
}

final class IssueListPresenter: IssueListPresenterInterface {
    
    let selectedIssue = PublishRelay<MGLIssue>()
    let loadMoreTrigger = PublishRelay<Void>()
    let refreshTrigger = PublishRelay<Void>()
    let didChangeTableContentOffsetY = PublishRelay<CGFloat>()
    
    // MARK: - Private properties -
    private var currentPageInfo = MGLPageInfo(hasNextPage: true, startCursor: "", endCursor: "", hasPreviousPage: false)
    private var currentPageInfoRelay = PublishRelay<MGLPageInfo>()
    
    private let currentRepository = "gnachman/iterm2"
    
    private lazy var fetchIssueListAction = makeFetchIssueListAction()
    private let disposeBag = DisposeBag()
    
    private unowned let view: IssueListViewInterface
    private let interactor: IssueListInteractorInterface
    private let wireframe: IssueListWireframeInterface
    
    // MARK: - Lifecycle -
    
    init(
        view: IssueListViewInterface,
        interactor: IssueListInteractorInterface,
        wireframe: IssueListWireframeInterface
    ) {
        self.view = view
        self.interactor = interactor
        self.wireframe = wireframe
        
        configure()
    }
}

extension IssueListPresenter {
    func configure() {
        configurePresenter()
        configureRouter()
        configureViewActions()
        configureRestorationState()
    }
}

extension IssueListPresenter {
    private func configurePresenter() {
        
        view.startLoading()
        
        fetchIssueListAction
            .elements
            .map { $0.issues }
            .map { $0.map { DSIssueViewModel(model: $0) } }
            .map { [weak self] newViewModels -> [DSIssueViewModel] in
                
                guard (self?.currentPageInfo.hasPreviousPage).or(false),
                      let currentViewModels = self?.view.viewModels.value
                else { return newViewModels }
                
                return currentViewModels + newViewModels
            }
            .subscribeNext { [weak view] viewModels in
                view?.viewModels.accept(viewModels)
                view?.endLoading(error: nil)
            }
            .disposed(by: disposeBag)
        
        fetchIssueListAction
            .elements
            .map { $0.pageInfo }
            .subscribeNext { [weak self] pageInfo in
                self?.currentPageInfo = pageInfo
                self?.currentPageInfoRelay.accept(pageInfo)
            }
            .disposed(by: disposeBag)
        
        fetchIssueListAction
            .underlyingError
            .subscribeNext { [weak view] error in
                view?.endLoading(error: error)
            }
            .disposed(by: disposeBag)
        
        if AppState.shared.issueListActityState.latestViewModels.isEmpty {
            let request = IssueListRequest(gitlabRepository: currentRepository, after: currentPageInfo.endCursor)
            currentPageInfoRelay.accept(currentPageInfo)
            fetchIssueListAction.execute(request)
        }
        
        
    }
}

extension IssueListPresenter {
    private func configureViewActions() {
        loadMoreTrigger
            .map { [weak self] in self?.currentPageInfo }
            .filterNil()
            .filter { $0.hasNextPage }
            .map { $0.endCursor }
            .subscribeNext { [weak self] after in
                guard let self = self else { return }
                let request = IssueListRequest(gitlabRepository: self.currentRepository, after: after)
                self.fetchIssueListAction.execute(request)
            }
            .disposed(by: disposeBag)
        
        refreshTrigger
            .subscribeNext { [weak self] _ in
                guard let self = self else { return }
                self.currentPageInfo = .init(hasNextPage: true, startCursor: "", endCursor: "", hasPreviousPage: false )
            }
            .disposed(by: disposeBag)
    }
    
}

extension IssueListPresenter {
    private func configureRouter() {
        selectedIssue
            .subscribeNext { [weak wireframe] selectedIssue in
                wireframe?.navigate(to: .issueDetail(issue: selectedIssue))
            }
            .disposed(by: disposeBag)
    }
}

extension IssueListPresenter {
    private func configureRestorationState() {
        
        if AppState.shared.issueListActityState.latestViewModels.isNotEmpty {
            view.viewModels.accept(AppState.shared.issueListActityState.latestViewModels)
            currentPageInfo = AppState.shared.issueListActityState.pageInfo
            view.tableViewContentOffsetY.accept(AppState.shared.issueListActityState.tableContentOffsetY)
            view.endLoading(error: nil)
        }
        
        Observable.combineLatest(
            didChangeTableContentOffsetY,
            currentPageInfoRelay,
            view.viewModels
        )
        .map { data in
            AppState.IssueListActityState(tableContentOffsetY: data.0, pageInfo: data.1, l: data.2)
        }
        .subscribeNext { issuesListActivityState in
            AppState.shared.issueListActityState = issuesListActivityState
        }
        .disposed(by: disposeBag)
    }
}

// MARK: - Extensions -

extension IssueListPresenter {
    func makeFetchIssueListAction() -> Action<IssueListRequest, MGLIssuePagination> {
        return Action<IssueListRequest, MGLIssuePagination> { [weak self] request in
            guard let self = self else { return Observable.never() }
            return self.interactor.fetchIssues(of: request.gitlabRepository, after: request.after)
        }
    }
}

struct IssueListRequest {
    let gitlabRepository: String
    let after: String
}
